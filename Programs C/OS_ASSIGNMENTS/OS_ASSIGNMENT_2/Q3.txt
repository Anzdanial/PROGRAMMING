#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>
#include <mqueue.h>
#include <stdbool.h>
#include <string.h>


 const char * lowerCase(char* array){
    int size;
    for(size = 0; array[size]!='\0'; size++);
    for(int i = 0; i < size; i++){
        if(array[i] > 64 && array[i] < 91) {
            array[i] = array[i] + 32;
        }
    }
    return array;
}

int getSize(char *array){
    int size;
    for(size = 0; array[size]!='\0'; size++);
    return size;
}

int wordCounter(char array[], int size){
    int wordCounter = 0;
    for(int i = 0; i < size; i++){
        if(array[i+1] == ' ' || i+1 >= size)
            wordCounter++;
    }
    return wordCounter;
}

char ** storeWords(char array[], int size) {
    int wordCount = wordCounter(array, size);
    char **words = (char **) malloc(wordCount * sizeof(char *));
    int startIndex, endIndex = 0, space = 0, counter = 0;
    bool flag;
    for (int i = 0; i < size; i++) {
        flag = false;
        if (space > 0)
            startIndex = endIndex + 1;
        else
            startIndex = 0;
        if (array[i + 1] == ' ' || i+1 == size) {
            endIndex = i + 1;
            words[counter] = (char *) malloc((endIndex - startIndex) * sizeof(char));
            for (int j = 0, k = startIndex; k < endIndex; k++, j++) {
                words[counter][j] = array[k];
            }
            space++;
            flag = true;
        }
        if (flag)
            counter++;
    }
    return words;
}


char ** uniqueWordCounter(char **words, int totalWords, int *duplicates, int *uniqueSize){
    char **uniqueWords;
    int counter = 0;
    int *arrayFlag = (int *) malloc((totalWords) * sizeof(int));
    for(int i = 0; i < totalWords; i++){ arrayFlag[i] = 0;}
    for(int i = 0; i < totalWords; i++){
        for(int j = i+1; j < totalWords; j++){;
            if(strcmp(lowerCase(words[i]),lowerCase(words[j])) == 0) {
                if(arrayFlag[j] == 0) {
                    arrayFlag[j] = j;
                }
                if(arrayFlag[i] > 0){
                    continue;
                }
                else {
                    counter++;
                }
            }
        }
    }
    uniqueWords = (char **) malloc((totalWords - counter) * sizeof(char *));
    for(int i = 0, k = 0; i < totalWords; i++){
        if(arrayFlag[i] > 0) {
            continue;
        }
        else{
            uniqueWords[k] = (char *) malloc((getSize(words[i])) * sizeof(char));
            uniqueWords[k] = words[i];
            k++;
        }
    }
    for(int i = 0; i < (totalWords - counter); i++){
        printf("%s \n",uniqueWords[i]);
    }
    *duplicates = counter;
    *uniqueSize = totalWords - counter;
    return uniqueWords;
}

int main(int argc, char **argv) {
    if(argc < 2){
        fprintf(stderr,"No Input Given \n");
        return 1;
    }
    int N = atoi(argv[1]);

    int fd, size;
    char data[1024];
    fd = open("data.txt", O_RDONLY);
    if(fd < 0){
        perror("Couldn't Read File \n");
        exit(1);
    }
    size = read(fd, data, sizeof(data));
    data[size] = '\0';

    int wordsSize = wordCounter(data, size);
    char **words = storeWords(data, size);
    int duplicates = 0, uniqueSize = 0;
    char **uniqueWords = uniqueWordCounter(words,wordsSize, &duplicates,&uniqueSize);
    for(int i = 0; i < uniqueSize; i++){
        printf("%s \n",uniqueWords[i]);
    }
    return 0;
}










#include <stdio.h>

#include <stdlib.h>

#include <string.h>

#include <pthread.h>


/*Structure for storing words received from each thread*/

struct return_val {
    char wordlist[100][100];
    int count[100];

}
*arr;


pthread_t *threads;

int lines;


/*Aggregates Frequency Sum of different threads*/



int aggregate(char *a) {

    int sum = 0;

    int i = 0;


    while (1) {

        if (i == lines) break;

        int count = 0;

        while (1) {

            if (arr[i].count[count] == -1) {

                break;

            }


            if (strcmp(a, arr[i].wordlist[count]) == 0) {

                sum += arr[i].count[count];

                arr[i].count[count] = 0;


            }

            count++;

        }

        i++;


    }
    return sum;
}


/*Function executed by each  thread on separate line*/



void *word_count(void *num) {


    int *ln = num;

    unsigned int line_number = *ln;

    line_number++;


    char cmd_p1[9] = "sed -n '\0";

    char cmd_p2[2];

    sprintf(cmd_p2, "%d", line_number);

    char cmd_p3[14] = "p' 'file.txt'\0";

    char command[100];

    command[0] = '\0';

    strcat(command, cmd_p1);

    strcat(command, cmd_p2);

    strcat(command, cmd_p3);

    //usleep(line_number);



    char cmd[100] = " | tr [:space:] '\\n' | grep -v '^\\s*$' | sort | uniq -c | sort\0";

    strcat(command, cmd);


    FILE *in;

    in = popen(command, "r");

    rewind(in);

    char buff[50];

    int counter = 0;

    while (fgets(buff, sizeof(buff), in)) {

        char c = ' ';

        int i = 0;

        int cnt = atoi(buff);

        arr[line_number - 1].count[counter] = cnt;


        while (c != '\0') {

            c = buff[i];

            buff[i] = buff[i + 6];

            i++;

        }
        int cnnt = 0;
        while (c != ' ') {
            c = buff[cnnt];
            cnnt++;
        }
        i = 0;
        while (c != '\0') {
            c = buff[i];
            buff[i] = buff[i + cnnt];
            i++;
        }
        sprintf(arr[line_number - 1].wordlist[counter], "%s", buff);
        counter++;
    }
    arr[line_number - 1].count[counter] = -1;
    fclose(in);
    return NULL;
}


int main(void) {

    FILE *fp;
    fp = fopen("file.txt", "r");
    char a[200];
    lines = 0;
    void *status = NULL;
    while (fgets(a, sizeof(a), fp) != NULL) {
        lines++;

    }
    fclose(fp);
    arr = (struct return_val *) calloc(lines, sizeof(struct return_val) * lines);
    threads = malloc(sizeof(pthread_t) * lines);
    int i;
    for (i = 0; i < lines; i++) {
        pthread_create(&threads[i], NULL, word_count, &i);
        pthread_join(threads[i], status);

    }
    free(threads);
    char final[65536][20];
    int final_cnt[65536] = {0};
    int final_ctr = 0;
    i = 0;
    while (i != lines) {
        int ctr = 0;
        while (arr[i].count[ctr] >= 0) {
            if (arr[i].count[ctr] > 0) {
                strcpy(final[final_ctr], arr[i].wordlist[ctr]);
                final_cnt[final_ctr] = arr[i].count[ctr];
                arr[i].count[ctr] = 0;
                int sum = aggregate(arr[i].wordlist[ctr]);
                final_cnt[final_ctr] += sum;
                printf("%d  %s", final_cnt[final_ctr], final[final_ctr]);
            }
            ctr++;
            final_ctr++;

        }
        i++;
        if (i == lines) {
            break;

        }
    }
    free(arr);

    return 0;

}

